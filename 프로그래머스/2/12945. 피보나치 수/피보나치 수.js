function solution(n) {
  // 재귀함수를 통해 해결한 문제...
  // n이 커질수록 응답이 굉장히 느려져서 타임아웃
  function f(num) {
    if (num === 0 || num === 1) return num;
    return f(num - 2) + f(num - 1);
  }

  let answer = f(n);
  return answer % 1234567;
}
function solution(n) {
  // 모듈러 연산 이용해서 푼 방법
  // 숫자가 커질수록 오래걸리는 재귀함수보다 확실히 빠르고 간단함
  /*
    모듈러 연산의 분배법칙이란?
    큰 숫자를 다룰 때 매우 유용한 수학적 속성.

    모듈러 연산의 분배법칙:
    (a + b) % m = ((a % m) + (b % m)) % m

    설명:
    이 법칙은 큰 숫자들을 더한 후 나머지를 구하는 것과, 각 숫자의 나머지를 먼저 구한 뒤 더하고 다시 나머지를     구하는 것이 같다는 의미입니다.

    예시:
    17 % 5와 23 % 5의 합을 5로 나눈 나머지를 구해보기

    - 방법 1: (17 + 23) % 5 = 40 % 5 = 0
    - 방법 2: (17 % 5 + 23 % 5) % 5 = (2 + 3) % 5 = 5 % 5 = 0

    => 두 방법 모두 같은 결과를 얻음

    - 큰 수를 다룰 때 쓰면 좋음
    지금 이 문제에서는 각 단계에서 모듈러 연산을 적용해 0~1234566 사이의 값을 유지하게 되어 오버플로우를 막을 수 있음
    */

  // F(0), F(1)일때는 n 리턴
  if (n <= 1) return n;

  let a = 0;
  let b = 1;
  // f(1), f(2)는 위에서 N을 리턴하기 때문에
  // f(2)부터 시작하기 위해서 i=2로 시작함
  for (let i = 2; i <= n; i++) {
    let c = (a + b) % 1234567;
    a = b;
    b = c;

    /*
       * n = 5일 경우:
       a = 0 (F(0)), b = 1 (F(1))
       i = 2: c = (0 + 1) % 1234567 = 1, 그 다음 a = 1, b = 1
       i = 3: c = (1 + 1) % 1234567 = 2, 그 다음 a = 1, b = 2
       i = 4: c = (1 + 2) % 1234567 = 3, 그 다음 a = 2, b = 3
       i = 5: c = (2 + 3) % 1234567 = 5, 그 다음 a = 3, b = 5
       b가 새로 계산된 피보나치 수임
       */
  }
  return b;
}
